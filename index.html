<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>G4H - From embeddings to causal inference</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-46cbb8347319fcb2eb8c4f6a8afc9e17.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#medical-pathway-embeddings" id="toc-medical-pathway-embeddings" class="nav-link active" data-scroll-target="#medical-pathway-embeddings"><span class="header-section-number">1</span> Medical pathway embeddings</a>
  <ul>
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data"><span class="header-section-number">1.1</span> Data</a></li>
  <li><a href="#transformer-based-models" id="toc-transformer-based-models" class="nav-link" data-scroll-target="#transformer-based-models"><span class="header-section-number">1.2</span> Transformer-based models</a>
  <ul>
  <li><a href="#architecture" id="toc-architecture" class="nav-link" data-scroll-target="#architecture"><span class="header-section-number">1.2.1</span> Architecture</a></li>
  <li><a href="#sec-pre-training" id="toc-sec-pre-training" class="nav-link" data-scroll-target="#sec-pre-training"><span class="header-section-number">1.2.2</span> Pre-training strategy</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results"><span class="header-section-number">1.2.3</span> Results</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#causal-inference" id="toc-causal-inference" class="nav-link" data-scroll-target="#causal-inference"><span class="header-section-number">2</span> Causal inference</a>
  <ul>
  <li><a href="#framework" id="toc-framework" class="nav-link" data-scroll-target="#framework"><span class="header-section-number">2.1</span> Framework</a></li>
  <li><a href="#estimating-the-cate" id="toc-estimating-the-cate" class="nav-link" data-scroll-target="#estimating-the-cate"><span class="header-section-number">2.2</span> Estimating the CATE</a>
  <ul>
  <li><a href="#assumptions" id="toc-assumptions" class="nav-link" data-scroll-target="#assumptions"><span class="header-section-number">2.2.1</span> Assumptions</a></li>
  <li><a href="#estimators" id="toc-estimators" class="nav-link" data-scroll-target="#estimators"><span class="header-section-number">2.2.2</span> Estimators</a>
  <ul class="collapse">
  <li><a href="#s-learner-t-learner" id="toc-s-learner-t-learner" class="nav-link" data-scroll-target="#s-learner-t-learner">S-learner &amp; T-learner</a></li>
  <li><a href="#r-learner" id="toc-r-learner" class="nav-link" data-scroll-target="#r-learner">R-learner</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-benchmarks" id="toc-sec-benchmarks" class="nav-link" data-scroll-target="#sec-benchmarks"><span class="header-section-number">2.3</span> Benchmarks</a>
  <ul>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/meilame-tayebjee/G4H-Report/blob/main/index.qmd" class="toc-action"><i class="bi bi-github"></i>View source</a></li><li><a href="https://github.com/meilame-tayebjee/G4H-Report/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/meilame-tayebjee/G4H-Report/edit/main/index.qmd" class="toc-action"><i class="bi empty"></i>Edit this page</a></li></ul></div><div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="G4H-report.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">G4H - From embeddings to causal inference</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Meilame Tayebjee </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="medical-pathway-embeddings" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Medical pathway embeddings</h1>
<section id="data" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="data"><span class="header-section-number">1.1</span> Data</h2>
<p>We consider a dataset <span class="math inline">(X_i)_{i = 1..n}</span> of <em>medical pathways</em>. For each patient <span class="math inline">i</span>, <span class="math inline">X_i \coloneqq (e_i, t_i, f_i)</span>, where:</p>
<ul>
<li><span class="math inline">e_i \in \mathbb{R}^{cs}</span> denotes the vector of <em>tokenized events</em>. It is a tensor<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> which size is common for all patients<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> (an hyperparameter called the context size, <span class="math inline">cs</span>), that contains integers between <span class="math inline">0</span> and the vocabulary size <span class="math inline">\lvert \mathcal{V} \rvert</span>.</li>
<li><span class="math inline">t_i \in \mathbb{R}^{cs}</span> is the temporal vector, containing the dates<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> for each event in <span class="math inline">e_i</span>. For now we only consider consultation and medication type of events.</li>
<li><span class="math inline">f_i \in \mathbb{R}^{2}</span> corresponds to the patient general features, for now age and gender.</li>
</ul>
<p>At this stage, the pathways only contain consultations and pharmaceuticals events. We plan to add way more types of event, including deaths, hospitalizations, medical procedures etc.</p>
</section>
<section id="transformer-based-models" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="transformer-based-models"><span class="header-section-number">1.2</span> Transformer-based models</h2>
<section id="architecture" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="architecture"><span class="header-section-number">1.2.1</span> Architecture</h3>
<ul>
<li><p>An embedding matrix of size <span class="math inline">\mathbb{R}^{\lvert \mathcal{V} \rvert, d_{embed}}</span> projects each token of the sequence to an embedding vector. Adapting from the classical Transformer, we use <span class="math inline">t_i</span> to have a <em>time-aware</em> positional encoding using a sinusoidal encoding. At the beginning of the sequence, we add a symbolic [START] token, composed of the summed embeddings of age and gender.</p></li>
<li><p>These embeddings are then passed to <strong>causal</strong><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> self-attention layers, so that the Transformer-based model outputs <em>causally contextualized embeddings</em> for each token so that: <span class="math display"> GPT_{\theta}(X_i) \in \mathbb{R}^{cs, d_{embed}}</span> where <span class="math inline">\theta</span> parametrizes the neural network.</p></li>
</ul>
</section>
<section id="sec-pre-training" class="level3" data-number="1.2.2">
<h3 data-number="1.2.2" class="anchored" data-anchor-id="sec-pre-training"><span class="header-section-number">1.2.2</span> Pre-training strategy</h3>
<p>At a given position in the pathway, we consider the pre-training task of predicting, for each token, if it will appear within the next <span class="math inline">t</span> days. We consider, simulatenously, several <span class="math inline">t \in \mathcal{T}</span>, <span class="math inline">\mathcal{T}</span> being the sorted set of <em>short term horizons</em>, typically 14, 30, 60, 90, 180 days.</p>
<p>Let, for this task:</p>
<ul>
<li><span class="math inline">g_{\phi} \colon \mathbb{R}^{cs, d_{embed}} \to [0, 1]^{cs, \lvert \mathcal{V} \rvert, \lvert \mathcal{T} \rvert }</span> the neural prediction head for this task (parametrized by <span class="math inline">\phi</span>), on top of the Transformer layers</li>
<li>for a patient <span class="math inline">i</span>, <span class="math inline">Y_{i, \cdot, \cdot, \cdot} \in \{ 0, 1 \}^{cs, \lvert \mathcal{V} \rvert, \lvert \mathcal{T} \rvert}</span> the ground truth<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></li>
</ul>
<p>The pre-training solves:</p>
<span class="math display">\begin{align*}
\theta^{*}, \phi^{*} \in \arg\!\min \; &amp; \sum_{i=1}^{n} \sum_{\text{pos}=1}^{cs} \sum_{w \in \mathcal{V}} \sum_{t \in \mathcal{T}}
\text{BCE}\left(
    g_{\phi} \circ GPT_{\theta}(X_i)_{\text{pos}, w, t},
    Y_{i, \text{pos}, w, t}
\right) \\
&amp; + \lambda \, \text{Mon}\left( g_{\phi} \circ GPT_{\theta}(X_i) \right)
\end{align*}</span>
<p>where:</p>
<ul>
<li><span class="math inline">\text{BCE}(x,y) = y \log(x) + (1-y) \log(1-x)</span></li>
<li>for all <span class="math inline">i</span>, <span class="math inline">\text{Mon}\left( g_{\phi} \circ GPT_{\theta}(X_i) \right) \coloneqq</span></li>
</ul>
</section>
<section id="results" class="level3" data-number="1.2.3">
<h3 data-number="1.2.3" class="anchored" data-anchor-id="results"><span class="header-section-number">1.2.3</span> Results</h3>
<p>We trained a “large” model (40M parameters) and a “small” one (5M parameters). It seems that the big model improves the result, leading us to think there is a signal to capture and that the task is “learnable”.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/GPT_results/roc_spe_3.png" class="img-fluid figure-img"></p>
<figcaption>ROC curve of the pre-training task for a given specialty on a test set of 10,000 patients.</figcaption>
</figure>
</div>
<p>Still, the models converge quickly, and even small models achieve good convergence. This raises the (open) question of complexifying the task at some point.</p>
</section>
</section>
</section>
<section id="causal-inference" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Causal inference</h1>
<p>We are interested in the impact of losing one’s <em>Médecin Traitant</em> (Primary Care Provider, PCP) on different health outcomes, and ultimately how this impact is varying across several groups (for instance between regions with dense medical services and medical deserts). Such a shock - due to death or retirement of the doctor - affects approximately 1M patients in France every year (1,000 GPs are leaving each year, each one them being the PCP of 1,000 patients on average).</p>
<section id="framework" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="framework"><span class="header-section-number">2.1</span> Framework</h2>
<p>Up to a given time <span class="math inline">t</span>, we have:</p>
<ul>
<li>The covariate <span class="math inline">X_{&lt;t} \coloneqq (e_{&lt;t}, t_{&lt;t}, f_{&lt;t})</span>, the medical history of the patient</li>
<li><span class="math inline">W_t</span> is the treatment at time t and can either be:
<ol type="1">
<li>the proportion of days the patient has spent without a PCP during the period <span class="math inline">[t- \delta_{PCP}, t]</span>, <span class="math inline">\delta_{PCP}</span> being a hyperparameter controlling the length of the window</li>
<li>the maximum number of consecutive days without having a PCP, anytime in the past</li>
</ol></li>
<li><span class="math inline">Y_t (W_t)</span>, the binary outcome, indicating whether death has occured within a given time window <span class="math inline">[t, t+ \delta_d]</span>(which length <span class="math inline">\delta_d</span> is again chosen)</li>
</ul>
</section>
<section id="estimating-the-cate" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="estimating-the-cate"><span class="header-section-number">2.2</span> Estimating the CATE</h2>
<p>We want to estimate the <em>Conditional Average Treatment Effect</em> (CATE):</p>
<p><span class="math display"> \tau(x, w) \coloneqq \mathbb{E}[Y_t \mid X_{&lt;t} = x, W_t = w] </span></p>
<section id="assumptions" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="assumptions"><span class="header-section-number">2.2.1</span> Assumptions</h3>
<ul>
<li><p><strong>SUTVA</strong> : <span class="math display">Y_t(w) = Y_t \quad \textit{ if } W_t = w</span></p>
<ul>
<li>The others not having a PCP for a given amount of time does not influence my probability to die</li>
<li>Only one version of treatment ?</li>
</ul></li>
<li><p><strong>Conditional ignorability</strong></p></li>
</ul>
<p><span class="math display"> \forall w \in \mathbb{R}_{+}, Y_t(w) \perp W_t \mid X_{&lt;t}</span></p>
<ul>
<li><strong>Overlap</strong></li>
</ul>
<p><span class="math display"> 0 &lt; \mathbb{P}(W_t = w | X_{&lt;t} = x) &lt; 1, \forall (w,x) \in (\mathbb{R}_{+}, \mathbb{R}^{d_{embed}})</span></p>
</section>
<section id="estimators" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="estimators"><span class="header-section-number">2.2.2</span> Estimators</h3>
<p>For a given time t, we define <span class="math inline">{pos}_t</span> as being the last position in the patient’s pathway before <span class="math inline">t</span>, and we define the embedding of the pathway:</p>
<p><span class="math display"> GPT^{\text{path}}(X_{&lt;t}) \coloneqq GPT_{\theta^{*}}(X_{&lt;t})_{{pos}_t} \in \mathbb{R}^{d_{embed}} </span></p>
<section id="s-learner-t-learner" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="s-learner-t-learner">S-learner &amp; T-learner</h4>
<p>The S-learner is based on “outcome models” that try to capture the link between the outcome and the features (<span class="citation" data-cites="abecassis:hal-04774700">Abécassis et al. (<a href="#ref-abecassis:hal-04774700" role="doc-biblioref">2025</a>)</span>).</p>
<p>More precisely, we train on the <strong>validation set</strong> a head <span class="math inline">g_{\phi}: \mathbb{R}^{d_{embed}} \times \mathbb{R}_{+}  \to [0,1]</span> minimizing the binary cross-entropy loss on death prediction - to obtain <span class="math inline">\phi^{*}</span><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. At the end of the day:</p>
<p><span class="math display"> \hat{\tau}_{\text{SLearner}}(x, w) \coloneqq g_{\phi^{*}} (GPT^{\text{path}}(x), w) - g_{\phi^{*}} (GPT^{\text{path}}(x), 0)</span></p>
<p>where the baseline is “not having lost your PCP / having a PCP during all the period”.</p>
<p>🔴 There is no T-learner for continuous treatment, <em>a priori</em></p>
</section>
<section id="r-learner" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="r-learner">R-learner</h4>
<p>Another approach consists in trying to model the <em>propensity score</em>, the probability of being treated given <span class="math inline">X</span>.</p>
<p>A first head <span class="math inline">g_{\phi_{m}}: \mathbb{R}^{d_{embed}} \to [0,1]</span> is trained on the death prediction task, so that for a given pathway <span class="math inline">x</span>, <span class="math inline">g_{\phi_{m}^{*}}(GPT^{\text{path}}(x))</span> is <em>close</em> to the conditional mean outcome <span class="math inline">m(x) = \mathbb{E}[Y_t | x]</span>.</p>
<p>Another head <span class="math inline">g_{\phi_{e}}: \mathbb{R}^{d_{embed}} \to \mathbb{R}_+</span> is trained to predict the treatment <span class="math inline">W_t</span> of a given individual (minimizing a Mean Squared Error).</p>
<p>Finally, we train the CATE estimator training a head <span class="math inline">g_{\phi_{\tau}}: \mathbb{R}^{d_{embed}} \to [0,1]</span> by minimizing the <em>R-loss</em>:</p>
<p><span class="math display">\begin{align*}
\phi_{\tau}^{*} \in \arg\!\min_{\phi_{\tau}} \; &amp;
Y_t - g_{\phi_{m}^{*}}\left( GPT^{\text{path}}(X_{&lt;t}) \right) \\
&amp; - \left( W_t - g_{\phi_{e}^{*}}\left( GPT^{\text{path}}(X_{&lt;t}) \right) \right)
\cdot g_{\phi_{\tau}}\left( GPT^{\text{path}}(X_{&lt;t}) \right)
\end{align*}</span></p>
<p>🔴 There is no DR-learner for continuous treatment, <em>a priori</em></p>
</section>
</section>
</section>
<section id="sec-benchmarks" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="sec-benchmarks"><span class="header-section-number">2.3</span> Benchmarks</h2>
<p>WIP</p>
<section id="references" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="references">References</h3>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-abecassis:hal-04774700" class="csl-entry" role="listitem">
Abécassis, Judith, Élise Dumas, Julie Alberge, and Gaël Varoquaux. 2025. <span>“<span class="nocase">From prediction to prescription: Machine learning and Causal Inference</span>.”</span> <em><span>Annual Review of Biomedical Data Science</span></em>, April. <a href="https://doi.org/10.1146/annurev-biodatasci-103123-095750">https://doi.org/10.1146/annurev-biodatasci-103123-095750</a>.
</div>
</div>


</section>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Actually, we consider several tensors (and several vocabulary sizes) - one for each <em>type</em> of tokens, but we do not get into the details here.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Shorter sequences are <em>padded</em>, longer are cropped.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>To describe a date, we actually use the number of days since 01/01/2016, the start of the available dataset<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>The rationale for having a causal mask is that we want to be able to exploit any embedding at any time (with only one inference pass through the model) without them having “seen” the future. Typically, the pre-training task (see <a href="#sec-pre-training" class="quarto-xref">Section&nbsp;1.2.2</a>) is such a task. However, we still plan to train a BERT - pre-training task is still in discussion (see <a href="#sec-benchmarks" class="quarto-xref">Section&nbsp;2.3</a>).<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>For each short term horizon <span class="math inline">t</span>, we crop the pathways <span class="math inline">t</span> before the end date of our dataset so that we can always compute a ground truth<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>In this formulation, we assume that the embeddings are <em>frozen</em> (we only train <span class="math inline">\phi</span> at <span class="math inline">\theta^{*}</span> constant). Another alternative is to <em>fine-tune</em> the Transformer model, training both <span class="math inline">\phi</span> and <span class="math inline">\theta</span> here, with the same task, same loss, same dataset. This is true for all the remaining of this document.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/meilame-tayebjee\.github\.io\/G4H-Report\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/meilame-tayebjee/G4H-Report/blob/main/index.qmd" class="toc-action"><i class="bi bi-github"></i>View source</a></li><li><a href="https://github.com/meilame-tayebjee/G4H-Report/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/meilame-tayebjee/G4H-Report/edit/main/index.qmd" class="toc-action"><i class="bi empty"></i>Edit this page</a></li></ul></div></div></div></footer></body></html>