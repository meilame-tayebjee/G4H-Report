[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "G4H - From embeddings to causal inference",
    "section": "",
    "text": "We consider a dataset (X_i)_{i = 1..n} of medical pathways. For each patient i, X_i \\coloneqq (e_i, t_i, f_i), where:\n\ne_i \\in \\mathbb{R}^{cs} denotes the vector of tokenized events. It is a tensor1 which size is common for all patients2 (an hyperparameter called the context size, cs), that contains integers between 0 and the vocabulary size \\lvert \\mathcal{V} \\rvert.\nt_i \\in \\mathbb{R}^{cs} is the temporal vector, containing the dates3 for each event in e_i. For now we only consider consultation and medication type of events.\nf_i \\in \\mathbb{R}^{2} corresponds to the patient general features, for now age and gender.\n\nAt this stage, the pathways only contain consultations and pharmaceuticals events. We plan to add way more types of event, including deaths, hospitalizations, medical procedures etc.\n\n\n\n\n\n\nAn embedding matrix of size \\mathbb{R}^{\\lvert \\mathcal{V} \\rvert, d_{embed}} projects each token of the sequence to an embedding vector. Adapting from the classical Transformer, we use t_i to have a time-aware positional encoding using a sinusoidal encoding. At the beginning of the sequence, we add a symbolic [START] token, composed of the summed embeddings of age and gender.\nThese embeddings are then passed to causal4 self-attention layers, so that the Transformer-based model outputs causally contextualized embeddings for each token so that:  GPT_{\\theta}(X_i) \\in \\mathbb{R}^{cs, d_{embed}} where \\theta parametrizes the neural network.\n\n\n\n\nAt a given position in the pathway, we consider the pre-training task of predicting, for each token, if it will appear within the next t days. We consider, simulatenously, several t \\in \\mathcal{T}, \\mathcal{T} being the sorted set of short term horizons, typically 14, 30, 60, 90, 180 days.\nLet, for this task:\n\ng_{\\phi} \\colon \\mathbb{R}^{cs, d_{embed}} \\to [0, 1]^{cs, \\lvert \\mathcal{V} \\rvert, \\lvert \\mathcal{T} \\rvert } the neural prediction head for this task (parametrized by \\phi), on top of the Transformer layers\nfor a patient i, Y_{i, \\cdot, \\cdot, \\cdot} \\in \\{ 0, 1 \\}^{cs, \\lvert \\mathcal{V} \\rvert, \\lvert \\mathcal{T} \\rvert} the ground truth5\n\nThe pre-training solves:\n\\begin{align*}\n\\theta^{*}, \\phi^{*} \\in \\arg\\!\\min \\; & \\sum_{i=1}^{n} \\sum_{\\text{pos}=1}^{cs} \\sum_{w \\in \\mathcal{V}} \\sum_{t \\in \\mathcal{T}}\n\\text{BCE}\\left(\n    g_{\\phi} \\circ GPT_{\\theta}(X_i)_{\\text{pos}, w, t},\n    Y_{i, \\text{pos}, w, t}\n\\right) \\\\\n& + \\lambda \\, \\text{Mon}\\left( g_{\\phi} \\circ GPT_{\\theta}(X_i) \\right)\n\\end{align*}\nwhere:\n\n\\text{BCE}(x,y) = y \\log(x) + (1-y) \\log(1-x)\nfor all i, \\text{Mon}\\left( g_{\\phi} \\circ GPT_{\\theta}(X_i) \\right) \\coloneqq\n\n\n\n\nWe trained a ‚Äúlarge‚Äù model (40M parameters) and a ‚Äúsmall‚Äù one (5M parameters). It seems that the big model improves the result, leading us to think there is a signal to capture and that the task is ‚Äúlearnable‚Äù.\n\n\n\nROC curve of the pre-training task for a given specialty on a test set of 10,000 patients.\n\n\nStill, the models converge quickly, and even small models achieve good convergence. This raises the (open) question of complexifying the task at some point."
  },
  {
    "objectID": "index.html#data",
    "href": "index.html#data",
    "title": "G4H - From embeddings to causal inference",
    "section": "",
    "text": "We consider a dataset (X_i)_{i = 1..n} of medical pathways. For each patient i, X_i \\coloneqq (e_i, t_i, f_i), where:\n\ne_i \\in \\mathbb{R}^{cs} denotes the vector of tokenized events. It is a tensor1 which size is common for all patients2 (an hyperparameter called the context size, cs), that contains integers between 0 and the vocabulary size \\lvert \\mathcal{V} \\rvert.\nt_i \\in \\mathbb{R}^{cs} is the temporal vector, containing the dates3 for each event in e_i. For now we only consider consultation and medication type of events.\nf_i \\in \\mathbb{R}^{2} corresponds to the patient general features, for now age and gender.\n\nAt this stage, the pathways only contain consultations and pharmaceuticals events. We plan to add way more types of event, including deaths, hospitalizations, medical procedures etc."
  },
  {
    "objectID": "index.html#transformer-based-models",
    "href": "index.html#transformer-based-models",
    "title": "G4H - From embeddings to causal inference",
    "section": "",
    "text": "An embedding matrix of size \\mathbb{R}^{\\lvert \\mathcal{V} \\rvert, d_{embed}} projects each token of the sequence to an embedding vector. Adapting from the classical Transformer, we use t_i to have a time-aware positional encoding using a sinusoidal encoding. At the beginning of the sequence, we add a symbolic [START] token, composed of the summed embeddings of age and gender.\nThese embeddings are then passed to causal4 self-attention layers, so that the Transformer-based model outputs causally contextualized embeddings for each token so that:  GPT_{\\theta}(X_i) \\in \\mathbb{R}^{cs, d_{embed}} where \\theta parametrizes the neural network.\n\n\n\n\nAt a given position in the pathway, we consider the pre-training task of predicting, for each token, if it will appear within the next t days. We consider, simulatenously, several t \\in \\mathcal{T}, \\mathcal{T} being the sorted set of short term horizons, typically 14, 30, 60, 90, 180 days.\nLet, for this task:\n\ng_{\\phi} \\colon \\mathbb{R}^{cs, d_{embed}} \\to [0, 1]^{cs, \\lvert \\mathcal{V} \\rvert, \\lvert \\mathcal{T} \\rvert } the neural prediction head for this task (parametrized by \\phi), on top of the Transformer layers\nfor a patient i, Y_{i, \\cdot, \\cdot, \\cdot} \\in \\{ 0, 1 \\}^{cs, \\lvert \\mathcal{V} \\rvert, \\lvert \\mathcal{T} \\rvert} the ground truth5\n\nThe pre-training solves:\n\\begin{align*}\n\\theta^{*}, \\phi^{*} \\in \\arg\\!\\min \\; & \\sum_{i=1}^{n} \\sum_{\\text{pos}=1}^{cs} \\sum_{w \\in \\mathcal{V}} \\sum_{t \\in \\mathcal{T}}\n\\text{BCE}\\left(\n    g_{\\phi} \\circ GPT_{\\theta}(X_i)_{\\text{pos}, w, t},\n    Y_{i, \\text{pos}, w, t}\n\\right) \\\\\n& + \\lambda \\, \\text{Mon}\\left( g_{\\phi} \\circ GPT_{\\theta}(X_i) \\right)\n\\end{align*}\nwhere:\n\n\\text{BCE}(x,y) = y \\log(x) + (1-y) \\log(1-x)\nfor all i, \\text{Mon}\\left( g_{\\phi} \\circ GPT_{\\theta}(X_i) \\right) \\coloneqq\n\n\n\n\nWe trained a ‚Äúlarge‚Äù model (40M parameters) and a ‚Äúsmall‚Äù one (5M parameters). It seems that the big model improves the result, leading us to think there is a signal to capture and that the task is ‚Äúlearnable‚Äù.\n\n\n\nROC curve of the pre-training task for a given specialty on a test set of 10,000 patients.\n\n\nStill, the models converge quickly, and even small models achieve good convergence. This raises the (open) question of complexifying the task at some point."
  },
  {
    "objectID": "index.html#framework",
    "href": "index.html#framework",
    "title": "G4H - From embeddings to causal inference",
    "section": "2.1 Framework",
    "text": "2.1 Framework\nUp to a given time t, we have:\n\nThe covariate X_{&lt;t} \\coloneqq (e_{&lt;t}, t_{&lt;t}, f_{&lt;t}), the medical history of the patient\nW_t is the treatment at time t and can either be:\n\nthe proportion of days the patient has spent without a PCP during the period [t- \\delta_{PCP}, t], \\delta_{PCP} being a hyperparameter controlling the length of the window\nthe maximum number of consecutive days without having a PCP, anytime in the past\n\nY_t (W_t), the binary outcome, indicating whether death has occured within a given time window [t, t+ \\delta_d](which length \\delta_d is again chosen)"
  },
  {
    "objectID": "index.html#estimating-the-cate",
    "href": "index.html#estimating-the-cate",
    "title": "G4H - From embeddings to causal inference",
    "section": "2.2 Estimating the CATE",
    "text": "2.2 Estimating the CATE\nWe want to estimate the Conditional Average Treatment Effect (CATE):\n \\tau(x, w) \\coloneqq \\mathbb{E}[Y_t \\mid X_{&lt;t} = x, W_t = w] \n\n2.2.1 Assumptions\n\nSUTVA : Y_t(w) = Y_t \\quad \\textit{ if } W_t = w\n\nThe others not having a PCP for a given amount of time does not influence my probability to die\nOnly one version of treatment ?\n\nConditional ignorability\n\n \\forall w \\in \\mathbb{R}_{+}, Y_t(w) \\perp W_t \\mid X_{&lt;t}\n\nOverlap\n\n 0 &lt; \\mathbb{P}(W_t = w | X_{&lt;t} = x) &lt; 1, \\forall (w,x) \\in (\\mathbb{R}_{+}, \\mathbb{R}^{d_{embed}})\n\n\n2.2.2 Estimators\nFor a given time t, we define {pos}_t as being the last position in the patient‚Äôs pathway before t, and we define the embedding of the pathway:\n GPT^{\\text{path}}(X_{&lt;t}) \\coloneqq GPT_{\\theta^{*}}(X_{&lt;t})_{{pos}_t} \\in \\mathbb{R}^{d_{embed}} \n\nS-learner & T-learner\nThe S-learner is based on ‚Äúoutcome models‚Äù that try to capture the link between the outcome and the features (Ab√©cassis et al. (2025)).\nMore precisely, we train on the validation set a head g_{\\phi}: \\mathbb{R}^{d_{embed}} \\times \\mathbb{R}_{+}  \\to [0,1] minimizing the binary cross-entropy loss on death prediction - to obtain \\phi^{*}6. At the end of the day:\n \\hat{\\tau}_{\\text{SLearner}}(x, w) \\coloneqq g_{\\phi^{*}} (GPT^{\\text{path}}(x), w) - g_{\\phi^{*}} (GPT^{\\text{path}}(x), 0)\nwhere the baseline is ‚Äúnot having lost your PCP / having a PCP during all the period‚Äù.\nüî¥ There is no T-learner for continuous treatment, a priori\n\n\nR-learner\nAnother approach consists in trying to model the propensity score, the probability of being treated given X.\nA first head g_{\\phi_{m}}: \\mathbb{R}^{d_{embed}} \\to [0,1] is trained on the death prediction task, so that for a given pathway x, g_{\\phi_{m}^{*}}(GPT^{\\text{path}}(x)) is close to the conditional mean outcome m(x) = \\mathbb{E}[Y_t | x].\nAnother head g_{\\phi_{e}}: \\mathbb{R}^{d_{embed}} \\to \\mathbb{R}_+ is trained to predict the treatment W_t of a given individual (minimizing a Mean Squared Error).\nFinally, we train the CATE estimator training a head g_{\\phi_{\\tau}}: \\mathbb{R}^{d_{embed}} \\to [0,1] by minimizing the R-loss:\n\\begin{align*}\n\\phi_{\\tau}^{*} \\in \\arg\\!\\min_{\\phi_{\\tau}} \\; &\nY_t - g_{\\phi_{m}^{*}}\\left( GPT^{\\text{path}}(X_{&lt;t}) \\right) \\\\\n& - \\left( W_t - g_{\\phi_{e}^{*}}\\left( GPT^{\\text{path}}(X_{&lt;t}) \\right) \\right)\n\\cdot g_{\\phi_{\\tau}}\\left( GPT^{\\text{path}}(X_{&lt;t}) \\right)\n\\end{align*}\nüî¥ There is no DR-learner for continuous treatment, a priori"
  },
  {
    "objectID": "index.html#sec-benchmarks",
    "href": "index.html#sec-benchmarks",
    "title": "G4H - From embeddings to causal inference",
    "section": "2.3 Benchmarks",
    "text": "2.3 Benchmarks\nWIP\n\nReferences\n\n\nAb√©cassis, Judith, √âlise Dumas, Julie Alberge, and Ga√´l Varoquaux. 2025. ‚ÄúFrom prediction to prescription: Machine learning and Causal Inference.‚Äù Annual Review of Biomedical Data Science, April. https://doi.org/10.1146/annurev-biodatasci-103123-095750."
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "G4H - From embeddings to causal inference",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nActually, we consider several tensors (and several vocabulary sizes) - one for each type of tokens, but we do not get into the details here.‚Ü©Ô∏é\nShorter sequences are padded, longer are cropped.‚Ü©Ô∏é\nTo describe a date, we actually use the number of days since 01/01/2016, the start of the available dataset‚Ü©Ô∏é\nThe rationale for having a causal mask is that we want to be able to exploit any embedding at any time (with only one inference pass through the model) without them having ‚Äúseen‚Äù the future. Typically, the pre-training task (see Section¬†1.2.2) is such a task. However, we still plan to train a BERT - pre-training task is still in discussion (see Section¬†2.3).‚Ü©Ô∏é\nFor each short term horizon t, we crop the pathways t before the end date of our dataset so that we can always compute a ground truth‚Ü©Ô∏é\nIn this formulation, we assume that the embeddings are frozen (we only train \\phi at \\theta^{*} constant). Another alternative is to fine-tune the Transformer model, training both \\phi and \\theta here, with the same task, same loss, same dataset. This is true for all the remaining of this document.‚Ü©Ô∏é"
  }
]